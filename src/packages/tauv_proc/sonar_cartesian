#!/usr/bin/env python3

import rospy
from tauv_msgs.msg import SonarPulse
from tauv_msgs.msg import SonarGraph
from tauv_msgs.msg import Pose
from std_msgs.msg import Header
import numpy as np
import scipy.ndimage
import scipy.signal
import matplotlib.pyplot as plt
import matplotlib
import math
import sys
import time
import pickle

time_list = []
time2_list = []
ignore = 6

class ClusterPotential():
    def __init__(self, POI_val, x, y, dim):
        self.POI = POI_val
        self.x = x
        self.y = y
        self.dim = dim

    def get_POI(self):
        return self.POI

    def get_x(self):
        return self.x

    def get_y(self):
        return self.y

    def get_next(self):
        nxt = []
        if(self.x>0):
            nxt.append([self.x-1, self.y])
            if(self.y>0):
                nxt.append([self.x-1,self.y-1])
            if(self.y+1<self.dim):
                nxt.append([self.x-1,self.y+1])
        if(self.x+1<self.dim):
            nxt.append([self.x+1, self.y])
            if(self.y>0):
                nxt.append([self.x+1,self.y-1])
            if(self.y+1<self.dim):
               nxt.append([self.x+1,self.y+1])
        if(self.y-1>0):
             nxt.append([self.x,self.y-1])
        if(self.y+1<self.dim):
            nxt.append([self.x,self.y+1])
        return nxt


class GraphContainer(SonarGraph):
    def __init__(self):
        #for noise calculations and preprocessing
        self.unpr_avg = 0
        self.unpr_std = 0
        self.heat_map_avg = 0
        self.heat_map_std = 0
        self.proc_dif_thresh = 1000
        self.POI_val = 1000
        self.POI_dif_thresh = 1000
        self.cluster_dif_max = 0

        self.proc_std_multiplier = 1
        self.POI_std_multiplier = 2

        #messaging setup
        self.pub = rospy.Publisher("sonar", SonarGraph, queue_size=10)
        rospy.init_node('sonar_map',anonymous=True)
        x=rospy.wait_for_message("sonar/pulse",SonarPulse)

        self.cur_angle = x.angle
        self.data_len = x.data_length

        rospy.Subscriber("sonar/pulse",SonarPulse, self.read)
        rospy.Subscriber("gnc/pose",Pose, self.update_position)

        self.round=400 #inspection area length (gradians)
        self.gradians=400
        self.completed_cycles = 0
        self.blur = 1
        self.cur_position = (0,0,0)
        self.cur_orientation = (0,0,0)
        self.angle_counter = 0
        self.heat_map_dim=500
        self.prev_time = -1
        self.prev2_time = -1
        #self.range = rospy.get_param('/vehicle_params/sonar/range')
        self.range = 10
        
        #self.global_range = rospy.get_param('/vehicle_params/sonar/global_range') #meters
        
        self.global_range = 21.0

        self.global_origin = (self.global_range/2.0, self.global_range/2.0)

        self.header=Header()
        self.unpr=[0]*self.gradians*(self.data_len)

        self.avg_weight = 1.5
        self.POI_weight = 2
        self.heat_map = np.reshape([0]*(self.heat_map_dim**2), (self.heat_map_dim,self.heat_map_dim))
        self.weighted_heat_map = np.reshape([0,0]*(self.heat_map_dim**2), (self.heat_map_dim,self.heat_map_dim,2))

        self.proc_heat_map = np.copy(self.heat_map)
        self.heat_map_POI = np.copy(self.heat_map)
        self.heat_map_clusters = np.copy(self.heat_map)
        self.cluster_queue = []

        #allows popups of graph
        matplotlib.use('gtk3agg')

        #self.plot = plt.imshow(np.reshape(self.unpr, (self.data_len,self.degrees)),cmap='jet') 
        self.plot = plt.imshow(self.heat_map,cmap='jet')
        plt.axis("off")
        plt.show()


    def read(self, data):
        self.exact_angle = self.calc_angle(data.angle)
        self.cur_angle = round(self.exact_angle)
        if self.cur_angle>=0 and self.cur_angle<self.gradians:
            for i in range(ignore,self.data_len):
                self.unpr[i*self.gradians+self.cur_angle]=data.data[i]
                if(data.data[i]>self.unpr_avg): #graph only above avg singals
                    self.plot_heat(data.data[i],i,self.exact_angle)
                else:
                    self.plot_heat(0,i,self.exact_angle)
        if(self.prev_time>-1):
            time_list.append((data.header.stamp.nsecs+data.header.stamp.secs*(10**9))-self.prev_time)
            time2_list.append(time.time()-self.prev2_time)
        self.prev_time = data.header.stamp.nsecs + data.header.stamp.secs*(10**9)
        self.prev2_time=time.time()
        #print(data.header)
        #print(self.angle_counter)

        #once per cycle
        if(self.angle_counter>self.round):
            self.completed_cycles+=1

            self.update_values()

            #self.display_img(self.proc_heat_map)

            self.gen_proc_heat_map()

            #self.display_img(np.reshape(self.weighted_heat_map[:,:,0:1],(self.heat_map_dim,self.heat_map_dim)))
           
            self.display_img(self.proc_heat_map)

            plt.savefig("proc_heat_map.png")

            #time.sleep(3)

            self.display_img(self.heat_map_clusters)

            #time.sleep(3)

            plt.savefig("clusters.png")

            self.angle_counter=0
        
        self.angle_counter+=1

        #self.display_img(np.reshape(self.weighted_heat_map[:,:,0:1],(self.heat_map_dim,self.heat_map_dim)))

        self.pub.publish(self)


    def update_values(self):
        time_avg = np.mean(time_list)
        time2_avg = np.mean(time2_list)
          
        with open('time.pkl', 'wb') as handle:
            pickle.dump((time_avg,time2_avg), handle, protocol=pickle.HIGHEST_PROTOCOL)

        with open('time.pkl', 'rb') as handle:
            b = pickle.load(handle)
            print(b[0]/(10.0**9))
            print(b[1])

        self.unpr_avg = np.mean(self.unpr)

        self.proc_heat_map = np.reshape(self.weighted_heat_map[:,:,0:1],(self.heat_map_dim,self.heat_map_dim))

        self.heat_map_std = np.std(self.heat_map)
        #print(self.heat_map_std)
        self.heat_map_avg = np.mean(self.heat_map)
        
        #blur the image
        self.proc_heat_map = scipy.ndimage.gaussian_filter(self.proc_heat_map,self.blur)

        self.proc_dif_thresh = self.heat_map_avg+self.heat_map_std
        #self.POI_val = self.heat_map_avg+self.POI_weight*self.heat_map_std
        self.POI_val = self.heat_map_avg + self.POI_weight*self.heat_map_std
        self.POI_dif_thresh = self.POI_std_multiplier*self.heat_map_std
        self.cluster_dif_max = self.heat_map_std

        #makes sure the cluster threshold is at most just the points on the map
        if(self.cluster_dif_max>=self.proc_dif_thresh):
            self.cluster_dif_max=self.proc_dif_thresh-1
	


    def display_img(self, graph):
        self.plot.set_data(graph)
        plt.draw()

    #accounts for boat position and returns current read angle
    def calc_angle(self,angle):
        (roll, pitch, yaw) = self.cur_orientation
        if(roll>0 or pitch>0):
            return -1
        return angle+yaw

    def update_position(self,data):
        self.cur_position = data.position
        self.cur_orientation = data.orientation

    def get_polar_point(self, col, row):
        y_dist = (row)*(self.global_range/self.heat_map_dim)-self.global_origin[1]
        x_dist = (col)*(self.global_range/self.heat_map_dim)-self.global_origin[0]
        r = math.sqrt(x_dist**2 + y_dist**2)
        
        theta = ((np.pi/2)-(np.arctan2(y_dist,x_dist)))%(2*np.pi)
        return (r,theta)

    def get_map_square(self, x, y):
        square_size = self.global_range/(self.heat_map_dim)
        row = round(y/square_size)
        col = round(x/square_size)
        return (row, col)

    def calc_grid_bounds(self, sq):
        min_x = sq[0][0]
        min_y = sq[0][1]
        max_x = sq[0][0]
        max_y = sq[0][1]
        for i in range(6):
            if(sq[i][0]<min_x):
                min_x = sq[i][0]
            elif(sq[i][0]>max_x):
                max_x = sq[i][0]
            if(sq[i][1]<min_y):
                min_y = sq[i][1]
            elif(sq[i][1]>max_y):
                max_y = sq[i][1]

        return ((min_x,max_x),(min_y,max_y))

    def is_in(self, corners, upper_r, lower_r, in_angle, out_angle):
        for i in range(4):
            if(corners[i][0]<=upper_r and corners[i][0]>=lower_r):
                if(corners[i][1]>=in_angle and corners[i][1]<=out_angle):
                    return True
                if((corners[i][1]+2*np.pi<=(2*np.pi+out_angle) and corners[i][1]+2*np.pi>=in_angle) or (corners[i][1]>=in_angle and corners[i][1]<=(np.pi*2+out_angle))):
                    return True
        return False


    def interpolate(self, data, lower_r, upper_r, in_angle, out_angle, left, right, top, bottom):
        #find arc area bounds
        for y in range(bottom, top+1):
            for x in range(left, right+1):
                #find 4 corners and see if one of them is in area
                c1 = self.get_polar_point(x,y)
                c2 = self.get_polar_point(x+1,y)
                c3 = self.get_polar_point(x+1,y+1)
                c4 = self.get_polar_point(x,y+1)

                if(self.is_in([c1,c2,c3,c4], upper_r, lower_r, in_angle, out_angle)):
                    self.heat_map[x][y]=data
                    self.weight_heat_point(x,y)


    def plot_heat(self, data, dist, angle):
        (x,y,z) = (self.cur_position[0]+self.global_origin[0],self.cur_position[1]+self.global_origin[1],self.cur_position[2])

        theta2 = math.radians(angle*360/400.0)
        
        dist = (dist/float(self.data_len))*self.range #get actual r
        dist_upper = dist + (self.range/float(self.data_len))

        if(angle==0):
            theta1 = math.radians((self.gradians-1)*360/400.0)
        else:
            theta1 = math.radians((angle-1)*360/400.0)
        if(angle==self.gradians-1):
            theta3 = 0 
        else:
            theta3 = math.radians((angle+1)*360/400.0)

        square2 = self.get_map_square(x+dist*math.cos(theta2), y+dist*math.sin(theta2))
        square1 = self.get_map_square(x+dist*math.cos(theta1),y+dist*math.sin(theta1))
        square3 = self.get_map_square(x+dist*math.cos(theta3),y+dist*math.sin(theta3))

        #can optimize here by passing prev squares to the next since continuous
        square4 = self.get_map_square(x+dist_upper*math.cos(theta1),y+dist*math.sin(theta1))
        square5 = self.get_map_square(x+dist_upper*math.cos(theta2),y+dist*math.sin(theta2))
        square6 = self.get_map_square(x+dist_upper*math.cos(theta3),y+dist*math.sin(theta3))

        self.heat_map[square1[0]][square1[1]]=data
        #self.heat_map[square2[0]][square2[1]]=data
        #self.heat_map[square3[0]][square3[1]]=data

        self.weight_heat_point(square1[0], square1[1])
        #self.weight_heat_point(square2[0],square2[1])
        #self.weight_heat_point(square3[0],square3[1])

        grid_bounds = self.calc_grid_bounds([square1,square2,square3,square4,square5,square6])
        
        self.interpolate(data,dist, dist_upper, theta1, theta3, grid_bounds[0][0],grid_bounds[0][1],grid_bounds[1][1],grid_bounds[1][0])


    def weight_heat_point(self, row, col):
        self.weighted_heat_map[row][col][0] = ((self.weighted_heat_map[row][col][0]*self.weighted_heat_map[row][col][1])+(self.heat_map[row][col]*self.avg_weight))/(self.weighted_heat_map[row][col][1]+self.avg_weight)
        self.weighted_heat_map[row][col][1]=self.weighted_heat_map[row][col][1]+1


    def gen_proc_heat_map(self):
        for row in range(self.heat_map_dim):
            for col in range(self.heat_map_dim):
                if(self.proc_heat_map[row][col]>self.proc_dif_thresh):
                    self.proc_heat_map[row][col] = self.proc_heat_map[row][col]
                    #self.weight_heat_point(row, col)
                    self.find_heat_map_POI(row, col, self.proc_heat_map)
                else:
                    self.proc_heat_map[row][col] = 0
                    #self.weight_heat_point(row, col)
                    self.heat_map_POI[row][col] = 0
	
        chistory_graph = np.reshape([0]*(self.heat_map_dim**2), (self.heat_map_dim,self.heat_map_dim))
        self.cluster_heat_map(chistory_graph)
	

    def find_heat_map_POI(self, row, col, graph):
        poi = 0
        if(col>0):
            if((graph[row][col]-graph[row][col-1])>self.POI_dif_thresh and graph[row][col]>self.POI_val):
               poi = 1
        if(row>0):
            if((graph[row][col]-graph[row-1][col])>self.POI_dif_thresh and graph[row][col]>self.POI_val):
               poi = 1
        if(row>0 and col>0):
            if((graph[row][col]-graph[row-1][col-1])>self.POI_dif_thresh and graph[row][col]>self.POI_val):
               poi = 1
        if(poi==1):
            self.cluster_queue.append(ClusterPotential(graph[row][col],row,col,self.heat_map_dim))
            self.heat_map_POI[row][col]=100
        else:
            self.heat_map_POI[row][col]=0


    def cluster_heat_map(self, chistory_graph):
        while(self.cluster_queue):
            nxt = self.cluster_queue.pop()
            row = nxt.get_x()
            col = nxt.get_y()

            if(chistory_graph[row][col] == 0):
                #if it is a cluster
                if(abs(self.proc_heat_map[row][col]-nxt.get_POI())<self.cluster_dif_max and self.proc_heat_map[row][col]>0):
                    #print("custered")
                    self.heat_map_clusters[row][col] = 100
                    chistory_graph[row][col] = 1
                    more = nxt.get_next()
                    for i in range(8):
                        self.cluster_enq(self.proc_heat_map[row][col], more[i])


    def cluster_enq(self, POI_val, point):
        self.cluster_queue.append(ClusterPotential(POI_val, point[0],point[1], self.heat_map_dim))


def sonar_listen():
    s = GraphContainer()
    rospy.spin()
    rospy.loginfo(f"{s.unpr}")

if __name__ == '__main__':
    sonar_listen()
