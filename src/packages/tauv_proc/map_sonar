#!/usr/bin/env python3

import rospy
from tauv_msgs.msg import SonarPulse
from tauv_msgs.msg import SonarGraph
from std_msgs.msg import Header
import numpy as np
import scipy.ndimage
import scipy.signal
import matplotlib.pyplot as plt
import matplotlib
import math
import sys
import heapq as hq
#from queue import PriorityQueue
sys.setrecursionlimit(5000)
#use scipy sudo apt-get install python3-scipy
#from scipy import fclusterdata
#from sklearn.cluster import KMeans

from dataclasses import dataclass, field
from typing import Any

@dataclass(order=True)
class PrioritizedItem:
    priority: int
    item: Any=field(compare=False)

#how much of surrounding data should sonar ignore
ignore=6

class ClusterPotential():
    def __init__(self, POI_val, angle, dist, dif, tot_dist, degrees):
        self.POI = POI_val
        self.angle = angle
        self.dist = dist
        self.dif=dif
        self.val=0
        self.tot_dist=tot_dist
        self.degrees=degrees

    def set_val(self,val,dif):
        self.val = val
        self.dif = dif

    def get_val(self):
        return self.val

    def get_POI(self):
        return self.POI

    def set_dif(self,dif):
        self.dif= dif

    def is_clust(self):
        if(abs(self.val - self.POI)<self.dif):
            return True
        return False

    def get_angle(self):
        return self.angle

    def get_dist(self):
        return self.dist

    def get_next(self):
        nxt = []
        if(self.angle-1>0):
            nxt.append([self.dist, self.angle-1])
            if(self.dist-1>0):
                nxt.append([self.dist-1,self.angle-1])
            else:
                nxt.append([self.tot_dist-1, self.angle-1])
            if(self.dist+1<self.tot_dist):
                nxt.append([self.dist+1,self.angle-1])
            else:
                nxt.append([0,self.angle-1])
        else:
            nxt.append([self.dist, self.degrees-1])
            if(self.dist-1>0):
                nxt.append([self.dist-1,self.degrees-1])
            else:
                nxt.append([self.tot_dist-1, self.degrees-1]) 
            if(self.dist+1<self.tot_dist):
                nxt.append([self.dist+1,self.degrees-1])
            else:
                nxt.append([0,self.degrees-1])
        if(self.angle+1<self.degrees):
            nxt.append([self.dist, self.angle+1])
            if(self.dist-1>0):
                nxt.append([self.dist-1,self.angle+1])
            else:
               nxt.append([self.tot_dist-1, self.angle+1])
            if(self.dist+1<self.tot_dist):
               nxt.append([self.dist+1,self.angle+1])
            else:
               nxt.append([0,self.angle+1])
        else:
            nxt.append([self.dist, 0])
            if(self.dist-1>0):
                nxt.append([self.dist-1,0])
            else:
                nxt.append([self.tot_dist-1,0])
            if([self.dist+1<self.tot_dist]):
                nxt.append([self.dist+1,0])
            else:
                nxt.append([0,0])
        if(self.dist-1>0):
             nxt.append([self.dist-1,self.angle])
        else:
             nxt.append([self.tot_dist-1,self.angle])
        if(self.dist+1<self.tot_dist):
            nxt.append([self.dist+1,self.angle])
        else:
            nxt.append([0,self.angle])
        return nxt

class GraphContainer(SonarGraph):
    def __init__(self):
        #for noise calculations
        self.avg_noise = 1000
        self.std = 1000
        #self.last_check = 0
        self.counter = 0
        self.dif_measure = 0
        #messaging setup
        self.pub = rospy.Publisher("sonar", SonarGraph, queue_size=10)
       
        rospy.init_node('map_sonar',anonymous=True)
   
        x=rospy.wait_for_message("data",SonarPulse)

        self.cur_angle = x.angle
        self.data_len = x.data_length
        self.true_data_len = x.data_length-ignore

        #inspection area length
        self.round=400
        self.cycles = 0
        self.delay = 3
        self.blur = 1.25
        self.dividend = 0
        #self.blur2 = .15
        self.avg = 0

        self.degrees=400

        rospy.Subscriber("data",SonarPulse, self.read)

        self.header=Header()
        self.unpr=[0]*self.degrees*(self.data_len)
        self.prc=np.reshape(self.unpr,(self.data_len,self.degrees)) #for graphing
        self.sprc=np.copy(self.prc) #for graphing
        self.POI = np.copy(self.prc)
        self.clusters = np.copy(self.prc)
        #self.cluster_blur = np.copy(self.prc)
        self.cluster_queue = []
        self.proc_sprc = np.copy(self.prc)
        self.temp_sprc = np.copy(self.prc)

        #allows popups of graph
        matplotlib.use('gtk3agg')
        #plt.ion()

        self.plot = plt.imshow(np.reshape(self.unpr, (self.data_len,self.degrees)),cmap='jet')
        plt.show()

    def read(self, data):
        #data.data = scipy.signal.medfilt(data.data)
        self.cur_angle = self.calc_angle(data.angle)
        if self.cur_angle>=0 and self.cur_angle<self.degrees:
            self.clusters[:,self.cur_angle:self.cur_angle+1]=np.reshape([0]*200,(200,1))
            for i in range(ignore,self.data_len):
                self.unpr[self.calc_dist(i)*self.degrees+self.cur_angle]=data.data[i]
                if(self.cycles>1):
                    self.find_POI(self.cur_angle-self.delay-1,i,self.sprc)
                #self.find_POI_by_med(self.cur_angle-self.delay-1,i)
                if data.data[i]>(self.avg_noise): #look into graphing only above avg singals
                    self.prc[self.calc_dist(i)][self.cur_angle]=data.data[i]
                else:
                    self.prc[self.calc_dist(i)][self.cur_angle]=0  
                if(self.sprc[i][self.cur_angle-(self.delay)-1]>self.avg+self.dividend*self.std):
                    #self.proc_sprc[i][self.cur_angle-self.delay-1]=255
                    self.proc_sprc[i][self.cur_angle-self.delay-1]=self.sprc[i][self.cur_angle-self.delay-1]
                else: 
                    self.proc_sprc[i][self.cur_angle-self.delay-1]=0
                '''if(self.proc_sprc[i][self.cur_angle-(self.delay)-10]>0):
                    self.temp_sprc[i][self.cur_angle-self.delay-10]=100
                else:
                    self.temp_sprc[i][self.cur_angle-self.delay-10]=0
                #if(self.clusters[i][self.cur_angle-self.delay-2]>0):
                #    self.temp_sprc[i][self.cur_angle-self.delay-2]=155'''
            #self.sprc[ignore:self.data_len, self.cur_angle:self.cur_angle+1]=self.prc[ignore:self.data_len,self.cur_angle:self.cur_angle+1] 
            if(self.cur_angle>=self.delay*2):
               #self.sprc[ignore:self.data_len, self.cur_angle-self.delay:self.cur_angle-self.delay+1] = self.prc[ignore:self.data_len, self.cur_angle-self.delay:self.cur_angle-self.delay+1] 
               self.sprc[ignore:self.data_len,self.cur_angle-self.delay:self.cur_angle-(self.delay-1)] = scipy.ndimage.gaussian_filter(self.prc[ignore:self.data_len,self.cur_angle-(self.delay*2):self.cur_angle+1],self.blur)[0:self.data_len-ignore,self.delay:self.delay+1]
            elif(self.cur_angle>=self.delay):
                self.sprc[ignore:self.data_len,self.cur_angle-self.delay:self.cur_angle-(self.delay-1)] = scipy.ndimage.gaussian_filter(np.concatenate((self.prc[ignore:self.data_len,self.degrees-2*self.delay+self.cur_angle:self.degrees],self.prc[ignore:self.data_len,0:self.cur_angle+1]),axis=1),self.blur)[0:self.data_len-ignore,self.delay:self.delay+1]
            else:
                self.sprc[ignore:self.data_len,self.degrees+self.cur_angle-self.delay:self.degrees+self.cur_angle-self.delay+1] = scipy.ndimage.gaussian_filter(np.concatenate((self.prc[ignore:self.data_len,self.degrees-2*self.delay+self.cur_angle:self.degrees],self.prc[ignore:self.data_len,0:self.cur_angle+1]),axis=1),self.blur)[0:self.data_len-ignore,self.delay:self.delay+1]
            '''proc_angle = self.cur_angle-self.delay
            if(proc_angle>=self.delay*2):
               #self.sprc[ignore:self.data_len, self.cur_angle-self.delay:self.cur_angle-self.delay+1] = self.prc[ignore:self.data_len, self.cur_angle-self.delay:self.cur_angle-self.delay+1] 
               self.proc_sprc[ignore:self.data_len,proc_angle-self.delay:proc_angle-(self.delay-1)] = scipy.ndimage.gaussian_filter(self.temp_sprc[ignore:self.data_len,proc_angle-(self.delay*2):proc_angle+1],self.blur2)[0:self.data_len-ignore,self.delay:self.delay+1]
            elif(proc_angle>=self.delay):
                self.sprc[ignore:self.data_len,proc_angle-self.delay:proc_angle-(self.delay-1)] = scipy.ndimage.gaussian_filter(np.concatenate((self.temp_sprc[ignore:self.data_len,self.degrees-2*self.delay+proc_angle:self.degrees],self.prc[ignore:self.data_len,0:proc_angle+1]),axis=1),self.blur2)[0:self.data_len-ignore,self.delay:self.delay+1]
            else:
                self.sprc[ignore:self.data_len,self.degrees+proc_angle-self.delay:self.degrees+proc_angle-self.delay+1] = scipy.ndimage.gaussian_filter(np.concatenate((self.temp_sprc[ignore:self.data_len,self.degrees-2*self.delay+proc_angle:self.degrees],self.prc[ignore:self.data_len,0:proc_angle+1]),axis=1),self.blur2)[0:self.data_len-ignore,self.delay:self.delay+1]
            '''
            #self.clusters_blur[ignore:self.data_len,self.cur_angle-10:self.cur_angle-9] = scipy.ndimage.gaussian_filter(self.prc[ignore:self.data_len,self.cur_angle-15:self.cur_angle-6],1)[0:self.data_len,5:6]
            #self.sprc[ignore:self.data_len,self.cur_angle:self.cur_angle+1] = scipy.ndimage.gaussian_filter(self.prc[ignore:self.data_len,self.cur_angle-5:self.cur_angle+5],(200,10))[0:self.data_len,5:6]
            #np.reshape([range(ignore,200),range(ignore,200),range(ignore,200),range(ignore,200),range(ignore,200)],(self.true_data_len,5)) #scipy.ndimage.gaussian_filter(self.prc[ignore:self.data_len,self.cur_angle-3:self.cur_angle+3],(200,5))
        else:
            rospy.logwarn("Error in calculated sub angle\n")

        self.pub.publish(self)
        #self.img = np.reshape(self.prc, (200,400))

        #self.detect_contrast()
        
        if(self.cur_angle>self.delay+1):
            self.deq_cluster(self.cur_angle-self.delay-1)
        else:
            self.deq_cluster(self.degrees-(self.delay+1-self.cur_angle))
        #print(self.cluster_queue)'''
        
        self.display_img(self.clusters)
        
        if self.counter>self.round:
            #self.sprc=[0]*self.degrees*(self.data_len) #for graphing
            self.avg_noise = np.mean(self.unpr)
            self.avg = np.mean(self.sprc)
            self.std = np.std(self.sprc)
            self.dif_measure = self.std
            self.counter=0 
            self.cycles+=1
            #self.cluster_queue.queue.clear()
        
        self.counter+=1
 
    #accounts for boat position and returns current read angle
    def calc_angle(self,angle):
        return round(angle)

    #accounts for boat position and returns distance of point
    def calc_dist(self, dist):
        return dist

    def display_img(self, graph):
        self.plot.set_data(graph)
        plt.draw()

        #img = Image.fromarray(array,'1')
        #img.save('graph1.png')
        #img = Image.frombytes('L',(400,200),array)
        #img.save('graph2.png')
        #plt.savefig("graph2.png")

    def find_POI(self, angle, dist, graph):
        poi = 0
        if(angle!=0):
            if(graph[dist][angle]-graph[dist][angle-1]>self.std and graph[dist][angle]>(self.avg+5*self.std)):
                poi = 1
        if(dist>ignore+1):
            if(graph[dist][angle]-graph[dist-1][angle]>self.std and graph[dist][angle]>(self.avg+5*self.std)):
                poi=1
        if(poi==1):
            hq.heappush(self.cluster_queue,PrioritizedItem(angle,(ClusterPotential(graph[dist][angle],angle,dist,self.dif_measure,self.data_len,self.degrees))))
            self.POI[dist][angle]=100
        else:
            self.POI[dist][angle]=0


    def find_POI_by_med(self,angle,dist):
        if(angle<0):
            angle = self.degrees + angle
        if(self.sprc[dist][angle]>(self.avg_noise + self.std)):
            self.POI[dist][angle]=100
            hq.heappush(self.cluster_queue,(PrioritizedItem(angle,(ClusterPotential(self.sprc[angle][dist],angle,dist,self.dif_measure,self.data_len,self.degrees)))))
        else:
            self.POI[dist][angle]=0

    def deq_cluster(self, angle):
        #print(len(self.cluster_queue))
        if(not self.cluster_queue):
            return
        nxt = hq.heappop(self.cluster_queue)
        #print("angle = " + str(angle))
        while(nxt.priority<=angle):
            #print("nxt prio = "+str(nxt.priority))
            dist = nxt.item.get_dist()
            angle2 = nxt.item.get_angle()
            if(self.clusters[dist][angle2]==0):
                nxt.item.set_val(self.sprc[dist][angle2],self.dif_measure)
                #print(" = ",nxt.item.get_POI())
                #print("val = ",nxt.item.get_val())
                if(self.proc_sprc[dist][angle2]>0 and nxt.item.is_clust()==True):
                    self.clusters[dist][angle2]=100
                    #self.temp_sprc[dist][angle2]=100
                    more = nxt.item.get_next()
                    for i in range(8):
                        self.cluster_enq(self.sprc[dist][angle2], more[i])
            if(not self.cluster_queue):
                return
            nxt = hq.heappop(self.cluster_queue)
        hq.heappush(self.cluster_queue,nxt)


    def sim_value(self, index):
        #if not at end of row
        if(index%(self.data_len)!=(self.degrees-1)%self.data_len):
            if abs(self.unpr[index+1]-self.unpr[index])<self.std:
                self.POI[index+1]=0
            else:
                self.POI[index+1]=100
        if(index<(self.degrees*self.data_len-self.degrees)):
            if abs(self.unpr[index+self.degrees]-self.unpr[index])<self.std:
                self.sprc[index+self.degrees]=0
            else:
                self.sprc[index+self.degrees]+=100
    

    def cluster(self, angle, dist):
        if(self.clusters[dist][angle]==0):
            self.clusters[dist][angle]=self.sprc[dist][angle]
            val = self.sprc[dist][angle]
            for i in range(1):
                if(angle>i):
                    if(self.clusters[dist][angle-i]==0 and abs(val-self.sprc[dist][angle-i])<self.dif_measure):
                        self.cluster(angle-i,dist)
                if(angle<self.degrees-i):
                    if(self.clusters[dist][angle+i]==0 and abs(val - self.sprc[dist][angle+i])<self.dif_measure):
                        self.cluster(angle+i,dist)
                if(dist>ignore+i):
                    if(self.clusters[dist-i][angle]==0 and abs(val - self.sprc[dist-i][angle])<self.dif_measure):
                        self.cluster(angle, dist-i)
                if(dist<self.data_len-i):
                    if(self.clusters[dist+i][angle]==0 and abs(val - self.sprc[dist+i][angle])<self.dif_measure):
                        self.cluster(angle,dist+i)


    def cluster_enq(self, ref_val, nxt):
        hq.heappush(self.cluster_queue,PrioritizedItem(nxt[1],ClusterPotential(ref_val, nxt[1],nxt[0],self.dif_measure,self.data_len,self.degrees)))


    def calc_avg_noise(self):
        #self.last_check = self.cur_angle
        angle = self.cur_angle
        round = self.round
        self.avg_noise = 0

        while(angle>=0 and round>0):
            for i in range(ignore,self.data_len):
                self.avg_noise +=self.unpr[self.calc_dist(i)*self.degrees+angle]
            angle-=1
            round-=1

        angle=self.degrees-1
        while(round>0):
            for i in range(ignore,self.data_len):
                self.avg_noise +=self.unpr[self.calc_dist(i)*self.degrees+angle]
                angle-=1
                round-=1
        self.avg_noise=self.avg_noise/(self.round*(self.true_data_len))

        rospy.loginfo(f"avg noise = {self.avg_noise}")
        self.calc_std()

    def calc_std(self):
        angle=self.cur_angle
        round=self.round
        self.std_noise=0

        while(angle>=0 and round>0):
            for i in range(ignore,self.data_len):
                self.std_noise += (self.avg_noise-self.unpr[self.calc_dist(i)*self.degrees+angle])*(self.avg_noise-self.unpr[self.calc_dist(i)*self.degrees+angle])
            angle-=1
            round-=1

        angle=self.degrees-1
        while(round>0):
            for i in range(ignore,self.data_len):
                self.std_noise += (self.avg_noise-self.unpr[self.calc_dist(i)*self.degrees+angle])*(self.avg_noise-self.unpr[self.calc_dist(i)*self.degrees+angle])
                angle-=1
                round-=1

        self.std_noise=math.sqrt(self.std_noise/(self.round*(self.true_data_len)))
        rospy.loginfo(f"avg std = {self.std_noise}")

    def detect_contrast(self,arr):
        angle=self.cur_angle

        std = np.std(arr)
        for i in range(ignore+1,self.data_len):
            if abs(arr[i-ignore]-arr[i-1-ignore])>std:
                self.prc[i][angle]=arr[i-ignore]
            else:
                self.prc[i][angle]=0

def sonar_listen():
    s = GraphContainer()
    rospy.spin()
    #arr = np.reshape(s.unpr, (200,400))
    rospy.loginfo(f"{s.unpr}")
    #rospy.loginfo(f"{arr}")

if __name__ == '__main__':
    sonar_listen()
