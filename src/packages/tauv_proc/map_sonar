#!/usr/bin/env python3

import rospy
from tauv_msgs.msg import SonarPulse
from tauv_msgs.msg import SonarGraph
from tauv_msgs.msg import PoseGraphMeasurement
from std_msgs.msg import Header
import numpy as np
import scipy.ndimage
import scipy.signal
import matplotlib.pyplot as plt
import matplotlib
import math
import sys
import heapq as hq
import time
import cv2
#from queue import PriorityQueue
sys.setrecursionlimit(5000)
#use scipy sudo apt-get install python3-scipy
#from scipy import fclusterdata
#from sklearn.cluster import KMeans

from dataclasses import dataclass, field
from typing import Any

@dataclass(order=True)
class PrioritizedItem:
    priority: int
    item: Any=field(compare=False)

#how much of surrounding data should sonar ignore
ignore=6

class ClusterPotential():
    def __init__(self, POI_val, angle, dist, dif, tot_dist, degrees):
        self.POI = POI_val
        self.angle = angle
        self.dist = dist
        self.dif=dif
        self.val=0
        self.tot_dist=tot_dist
        self.degrees=degrees

    def set_val(self,val,dif):
        self.val = val
        self.dif = dif

    def get_val(self):
        return self.val

    def get_POI(self):
        return self.POI

    def set_dif(self,dif):
        self.dif= dif

    def is_clust(self):
        if(abs(self.val - self.POI)<self.dif):
            return True
        return False

    def get_angle(self):
        return self.angle

    def get_dist(self):
        return self.dist

    def get_next(self):
        nxt = []
        if(self.angle-1>0):
            nxt.append([self.dist, self.angle-1])
            if(self.dist-1>0):
                nxt.append([self.dist-1,self.angle-1])
            else:
                nxt.append([self.tot_dist-1, self.angle-1])
            if(self.dist+1<self.tot_dist):
                nxt.append([self.dist+1,self.angle-1])
            else:
                nxt.append([0,self.angle-1])
        else:
            nxt.append([self.dist, self.degrees-1])
            if(self.dist-1>0):
                nxt.append([self.dist-1,self.degrees-1])
            else:
                nxt.append([self.tot_dist-1, self.degrees-1]) 
            if(self.dist+1<self.tot_dist):
                nxt.append([self.dist+1,self.degrees-1])
            else:
                nxt.append([0,self.degrees-1])
        if(self.angle+1<self.degrees):
            nxt.append([self.dist, self.angle+1])
            if(self.dist-1>0):
                nxt.append([self.dist-1,self.angle+1])
            else:
               nxt.append([self.tot_dist-1, self.angle+1])
            if(self.dist+1<self.tot_dist):
               nxt.append([self.dist+1,self.angle+1])
            else:
               nxt.append([0,self.angle+1])
        else:
            nxt.append([self.dist, 0])
            if(self.dist-1>0):
                nxt.append([self.dist-1,0])
            else:
                nxt.append([self.tot_dist-1,0])
            if([self.dist+1<self.tot_dist]):
                nxt.append([self.dist+1,0])
            else:
                nxt.append([0,0])
        if(self.dist-1>0):
             nxt.append([self.dist-1,self.angle])
        else:
             nxt.append([self.tot_dist-1,self.angle])
        if(self.dist+1<self.tot_dist):
            nxt.append([self.dist+1,self.angle])
        else:
            nxt.append([0,self.angle])
        return nxt

class GraphContainer(SonarGraph):
    def __init__(self):
        #for noise calculations
        self.avg_noise = 0
        self.std = 1000
        #self.last_check = 0
        self.counter = 0
        self.dif_measure = 0
        #messaging setup
        self.pub = rospy.Publisher("sonar", SonarGraph, queue_size=10)
       
        rospy.init_node('map_sonar',anonymous=True)
   
        x=rospy.wait_for_message("data",SonarPulse)

        self.cur_angle = x.angle
        self.data_len = x.data_length
        self.true_data_len = x.data_length-ignore
        rospy.Subscriber("odom",PoseGraphMeasurement, self.update_position)

        #inspection area length
        self.round=400
        self.cycles = 0
        self.delay = 3
        self.blur = 1.25
        self.dividend = 0
        #self.blur2 = .15
        self.avg = 0
        self.last_checked_pos = (0,0,0)
        self.cur_position = (0,0,0)
        self.last_checked_or = (0,0,0)
        self.cur_orientation = (0,0,0)
        self.heat_map_dim=500

        self.heat_map = np.reshape([0]*self.heat_map_dim**2, (self.heat_map_dim,self.heat_map_dim))

        #self.range = rospy.get_param('/vehicle_params/sonar/range')
        self.range = 10
        
        #print(self.range)
        #self.global_range = rospy.get_param('/vehicle_params/sonar/global_range') #meters
        
        self.global_range = 21.0

        self.global_origin = (self.global_range/2.0, self.global_range/2.0)

        self.degrees=400

        rospy.Subscriber("data",SonarPulse, self.read)

        self.header=Header()
        self.unpr=[0]*self.degrees*(self.data_len)
        self.prc=np.reshape(self.unpr,(self.data_len,self.degrees)) #for graphing
        self.sprc=np.copy(self.prc) #for graphing
        self.POI = np.copy(self.prc)
        self.clusters = np.copy(self.prc)
        #self.cluster_blur = np.copy(self.prc)
        self.cluster_queue = []
        self.proc_sprc = np.copy(self.prc)
        self.temp_proc = np.copy(self.prc)

        #allows popups of graph
        matplotlib.use('gtk3agg')
        #plt.ion()

        #self.plot = plt.imshow(np.reshape(self.unpr, (self.data_len,self.degrees)),cmap='jet') 
        self.plot = plt.imshow(self.heat_map,cmap='jet')
        plt.show()

    def read(self, data):
        #data.data = scipy.signal.medfilt(data.data)
        #temp = list()
        #self.display_img(self.heat_map)
        self.exact_angle = self.calc_angle(data.angle)
        self.cur_angle = round(self.exact_angle)
        if self.cur_angle>=0 and self.cur_angle<self.degrees:
            #self.clusters[:,self.cur_angle:self.cur_angle+1]=np.reshape([0]*200,(200,1))  
            #temp=np.reshape([0]*400*200,(200,400))
            for i in range(ignore,self.data_len):
                #self.plot_heat(255,i,self.exact_angle)
                self.unpr[self.calc_dist(i)*self.degrees+self.cur_angle]=data.data[i]
                if(self.cycles>1):
                    self.find_POI(self.cur_angle-self.delay-1,i,self.sprc)
                #self.find_POI_by_med(self.cur_angle-self.delay-1,i)
                if data.data[i]>(self.avg_noise): #look into graphing only above avg singals
                    self.prc[self.calc_dist(i)][self.cur_angle]=data.data[i]
                    self.plot_heat(data.data[i],i,self.exact_angle)
                else:
                    self.prc[self.calc_dist(i)][self.cur_angle]=0  
                    self.plot_heat(0,i,self.exact_angle)
                if(self.sprc[i][self.cur_angle-(self.delay)-1]>self.avg_noise+self.dividend*self.std):
                    #self.proc_sprc[i][self.cur_angle-self.delay-1]=255
                    self.proc_sprc[i][self.cur_angle-self.delay-1]=self.sprc[i][self.cur_angle-self.delay-1]
                else: 
                    self.proc_sprc[i][self.cur_angle-self.delay-1]=0
                #if(self.last_checked_pos!=self.cur_position):
                #    temp = self.transpose_row(self.last_checked_pos,self.cur_position,self.proc_sprc,temp,i*200/self.range)
                '''if(self.proc_sprc[i][self.cur_angle-(self.delay)-10]>0):
                    self.temp_sprc[i][self.cur_angle-self.delay-10]=100
                else:
                    self.temp_sprc[i][self.cur_angle-self.delay-10]=0
                #if(self.clusters[i][self.cur_angle-self.delay-2]>0):
                #    self.temp_sprc[i][self.cur_angle-self.delay-2]=155'''
            
            #self.proc_sprc = temp
            #self.sprc[ignore:self.data_len, self.cur_angle:self.cur_angle+1]=self.prc[ignore:self.data_len,self.cur_angle:self.cur_angle+1] 
            if(self.cur_angle>=self.delay*2):
               #self.sprc[ignore:self.data_len, self.cur_angle-self.delay:self.cur_angle-self.delay+1] = self.prc[ignore:self.data_len, self.cur_angle-self.delay:self.cur_angle-self.delay+1] 
               self.sprc[ignore:self.data_len,self.cur_angle-self.delay:self.cur_angle-(self.delay-1)] = scipy.ndimage.gaussian_filter(self.prc[ignore:self.data_len,self.cur_angle-(self.delay*2):self.cur_angle+1],self.blur)[0:self.data_len-ignore,self.delay:self.delay+1]
            elif(self.cur_angle>=self.delay):
                self.sprc[ignore:self.data_len,self.cur_angle-self.delay:self.cur_angle-(self.delay-1)] = scipy.ndimage.gaussian_filter(np.concatenate((self.prc[ignore:self.data_len,self.degrees-2*self.delay+self.cur_angle:self.degrees],self.prc[ignore:self.data_len,0:self.cur_angle+1]),axis=1),self.blur)[0:self.data_len-ignore,self.delay:self.delay+1]
            else:
                self.sprc[ignore:self.data_len,self.degrees+self.cur_angle-self.delay:self.degrees+self.cur_angle-self.delay+1] = scipy.ndimage.gaussian_filter(np.concatenate((self.prc[ignore:self.data_len,self.degrees-2*self.delay+self.cur_angle:self.degrees],self.prc[ignore:self.data_len,0:self.cur_angle+1]),axis=1),self.blur)[0:self.data_len-ignore,self.delay:self.delay+1]
            '''proc_angle = self.cur_angle-self.delay
            if(proc_angle>=self.delay*2):
               #self.sprc[ignore:self.data_len, self.cur_angle-self.delay:self.cur_angle-self.delay+1] = self.prc[ignore:self.data_len, self.cur_angle-self.delay:self.cur_angle-self.delay+1] 
               self.proc_sprc[ignore:self.data_len,proc_angle-self.delay:proc_angle-(self.delay-1)] = scipy.ndimage.gaussian_filter(self.temp_sprc[ignore:self.data_len,proc_angle-(self.delay*2):proc_angle+1],self.blur2)[0:self.data_len-ignore,self.delay:self.delay+1]
            elif(proc_angle>=self.delay):
                self.sprc[ignore:self.data_len,proc_angle-self.delay:proc_angle-(self.delay-1)] = scipy.ndimage.gaussian_filter(np.concatenate((self.temp_sprc[ignore:self.data_len,self.degrees-2*self.delay+proc_angle:self.degrees],self.prc[ignore:self.data_len,0:proc_angle+1]),axis=1),self.blur2)[0:self.data_len-ignore,self.delay:self.delay+1]
            else:
                self.sprc[ignore:self.data_len,self.degrees+proc_angle-self.delay:self.degrees+proc_angle-self.delay+1] = scipy.ndimage.gaussian_filter(np.concatenate((self.temp_sprc[ignore:self.data_len,self.degrees-2*self.delay+proc_angle:self.degrees],self.prc[ignore:self.data_len,0:proc_angle+1]),axis=1),self.blur2)[0:self.data_len-ignore,self.delay:self.delay+1]
            '''
            #self.clusters_blur[ignore:self.data_len,self.cur_angle-10:self.cur_angle-9] = scipy.ndimage.gaussian_filter(self.prc[ignore:self.data_len,self.cur_angle-15:self.cur_angle-6],1)[0:self.data_len,5:6]
            #self.sprc[ignore:self.data_len,self.cur_angle:self.cur_angle+1] = scipy.ndimage.gaussian_filter(self.prc[ignore:self.data_len,self.cur_angle-5:self.cur_angle+5],(200,10))[0:self.data_len,5:6]
            #np.reshape([range(ignore,200),range(ignore,200),range(ignore,200),range(ignore,200),range(ignore,200)],(self.true_data_len,5)) #scipy.ndimage.gaussian_filter(self.prc[ignore:self.data_len,self.cur_angle-3:self.cur_angle+3],(200,5))
        #else:
        #    rospy.logwarn("Error in calculated sub angle\n")

        self.pub.publish(self)
        #self.img = np.reshape(self.prc, (200,400))

        #self.detect_contrast()
        
        if(self.cur_angle>self.delay+1):
            self.deq_cluster(self.cur_angle-self.delay-1)
        else:
            self.deq_cluster(self.degrees-(self.delay+1-self.cur_angle))
        #print(self.cluster_queue)
        
        self.display_img(self.heat_map)
       
        #time.sleep(1)

        if self.counter>self.round:
            '''self.temp_proc = np.reshape([0]*200*400,(200,400))
            #self.prc = cv2.blur(self.prc,(5,5))
            ret,thresh = cv2.threshold(self.proc_sprc.astype(np.uint8),1,255, cv2.THRESH_BINARY)
            self.temp_proc = np.array(self.temp_proc).astype(np.uint8)
            contours, h = cv2.findContours(image=thresh,mode=cv2.RETR_TREE,method=cv2.CHAIN_APPROX_SIMPLE)
            #self.prc = cv2.cvtColor(self.prc,cv2.COLOR_GRAY2RGB)
            cv2.drawContours(image=self.temp_proc,contours=contours,contourIdx=-1,color=(255,0,0),thickness=1,lineType=cv2.LINE_AA)
            '''
            #self.sprc=[0]*self.degrees*(self.data_len) #for graphing
            #self.display_img(self.cv(self.proc_sprc))
            dif = self.avg_noise+self.dividend*self.std
            self.avg_noise = np.mean(self.unpr)
            self.avg = np.mean(self.sprc)
            self.std = np.std(self.sprc)
            self.dif_measure = self.std
            if(self.dif_measure>=dif):
                self.dif_measure=dif-1
            print(dif)
            self.counter=0 
            self.cycles+=1
            #self.cluster_queue.queue.clear()
        
        self.counter+=1
        self.display_img(self.heat_map)
        #time.sleep(1) 

    def update_position(self,data):
        self.cur_position = data.position
        self.cur_orientation = data.orientation

    def get_polar_point(self, col, row):
        y_dist = (row)*(self.global_range/self.heat_map_dim)-self.global_origin[1]
        x_dist = (col)*(self.global_range/self.heat_map_dim)-self.global_origin[0]
        r = math.sqrt(x_dist**2 + y_dist**2)
        
        theta = ((np.pi/2)-(np.arctan2(y_dist,x_dist)))%(2*np.pi)
        return (r,theta)

    def get_map_square(self, x, y):
        square_size = self.global_range/(self.heat_map_dim)
        row = round(y/square_size)
        col = round(x/square_size)
        return (row, col)

    def calc_grid_bounds(self, sq):
        min_x = sq[0][0]
        min_y = sq[0][1]
        max_x = sq[0][0]
        max_y = sq[0][1]
        for i in range(6):
            if(sq[i][0]<min_x):
                min_x = sq[i][0]
            elif(sq[i][0]>max_x):
                max_x = sq[i][0]
            if(sq[i][1]<min_y):
                min_y = sq[i][1]
            elif(sq[i][1]>max_y):
                max_y = sq[i][1]
        #print(str(((min_x,max_x),(min_y,max_y))))
        return ((min_x,max_x),(min_y,max_y))

    def is_in(self, corners, upper_r, lower_r, in_angle, out_angle):
        for i in range(4):
            if(corners[i][0]<=upper_r and corners[i][0]>=lower_r):
                if(corners[i][1]>=in_angle and corners[i][1]<=out_angle):
                    return True
                if((corners[i][1]+2*np.pi<=(2*np.pi+out_angle) and corners[i][1]+2*np.pi>=in_angle) or (corners[i][1]>=in_angle and corners[i][1]<=(np.pi*2+out_angle))):
                    return True
        return False


    def interpolate(self, data, lower_r, upper_r, in_angle, out_angle, left, right, top, bottom):
        #find arc area bounds
        #print("bottom = " + str(bottom)+" top = " + str(top))
        #print("left = " + str(left) + " right = " + str(right))
        for y in range(bottom, top+1):
            for x in range(left, right+1):
                #find 4 corners and see if one of them is in area
                c1 = self.get_polar_point(x,y)
                c2 = self.get_polar_point(x+1,y)
                c3 = self.get_polar_point(x+1,y+1)
                c4 = self.get_polar_point(x,y+1)
                
                #print("theta = "+str(c1[1]))
                #print("in_angle = " +str(in_angle) + " out = "+str(out_angle))

                if(self.is_in([c1,c2,c3,c4], upper_r, lower_r, in_angle, out_angle)):
                    self.heat_map[x][y]=data


    def plot_heat(self, data, dist, angle):
        (x,y,z) = (self.cur_position[0]+self.global_origin[0],self.cur_position[1]+self.global_origin[1],self.cur_position[2])
        #print("x = "+str(x)+"; y = " + str(y) ) 
        #theta1 = math.radians(angle - 1)
        theta2 = math.radians(angle*360/400.0)
        #theta3 = math.radians(angle +1)
        
        dist = (dist/float(self.data_len))*self.range #get actual r
        #print("range = "+str(self.range))
        dist_upper = dist + (self.range/float(self.data_len))

        if(angle==0):
            theta1 = math.radians((self.degrees-1)*360/400.0)
        else:
            theta1 = math.radians((angle-1)*360/400.0)
        if(angle==self.degrees-1):
            theta3 = 0 
        else:
            theta3 = math.radians((angle+1)*360/400.0)

        #print("dist = "+str(dist_upper))
        #print("angle = "+str(angle))

        square2 = self.get_map_square(x+dist*math.cos(theta2), y+dist*math.sin(theta2))
        square1 = self.get_map_square(x+dist*math.cos(theta1),y+dist*math.sin(theta1))
        square3 = self.get_map_square(x+dist*math.cos(theta3),y+dist*math.sin(theta3))
        #can optimize here by passing prev squares to the next since continuous
        square4 = self.get_map_square(x+dist_upper*math.cos(theta1),y+dist*math.sin(theta1))
        square5 = self.get_map_square(x+dist_upper*math.cos(theta2),y+dist*math.sin(theta2))
        square6 = self.get_map_square(x+dist_upper*math.cos(theta3),y+dist*math.sin(theta3))

        #print("angle = " +str(angle))
        #print("x coord = "+str(x+dist*math.cos(theta1))+" y coord = "+ str(y+dist*math.sin(theta1)))
        #print("sq1 = "+str(square1))

        self.heat_map[square1[0]][square1[1]]=data
        self.heat_map[square2[0]][square2[1]]=data
        self.heat_map[square3[0]][square3[1]]=data

        grid_bounds = self.calc_grid_bounds([square1,square2,square3,square4,square5,square6])
        
        #interpolate
        self.interpolate(data,dist, dist_upper, theta1, theta3, grid_bounds[0][0],grid_bounds[0][1],grid_bounds[1][1],grid_bounds[1][0])


    def cv(self,graph):
        res=np.reshape([0]*200*400,(200,400))
        ret,thresh = cv2.threshold(graph.astype(np.uint8),1,255,cv2.THRESH_BINARY)
        contours,h =cv2.findContours(image=thresh,mode=cv2.RETR_TREE,method=cv2.CHAIN_APPROX_SIMPLE)
        res=np.array(res).astype(np.uint8)
        cv2.drawContours(image=res,contours=contours,contourIdx=-1,color=(255,0,0),thickness=1,lineType=cv2.LINE_AA)
        return res

    #accounts for boat position and returns current read angle
    def calc_angle(self,angle):
        (roll, pitch, yaw) = self.cur_orientation
        if(roll>0 or pitch>0):
            return -1
        return angle+yaw

    #accounts for boat position and returns distance of point
    def calc_dist(self, dist):
        (roll, pitch, yaw) = self.cur_orientation
        if(roll>0 or pitch>0):
            return -1
        return dist

    def transpose_row(self, prev_pos, cur_pos, graph, new_graph, r1):
        x1 = prev_pos[0]
        y1=prev_pos[1]
        x2 = cur_pos[0]
        y2 = cur_pos[1]
        for i in range(self.ignore, self.degrees):
            rad = i*0.01570796
            (x3,y3) = (r1*math.cos(rad)+x1,r1*math.sin(rad)+y1)
            dify32 = y3-y2
            difx32 = x3-x2
            (t3,r3) = (round(math.atan(dify32/difx32)),round(math.sqrt(difx32**2,dify32**2)))
            new_graph[r3][t3]=graph[r1][i]
        return new_graph
    
    def display_img(self, graph):
        self.plot.set_data(graph)
        plt.draw()

        #img = Image.fromarray(array,'1')
        #img.save('graph1.png')
        #img = Image.frombytes('L',(400,200),array)
        #img.save('graph2.png')
        #plt.savefig("graph2.png")

    def find_POI(self, angle, dist, graph):
        poi = 0
        if(angle!=0):
            if(graph[dist][angle]-graph[dist][angle-1]>self.std and graph[dist][angle]>(self.avg+5*self.std)):
                poi = 1
        if(dist>ignore+1):
            if(graph[dist][angle]-graph[dist-1][angle]>self.std and graph[dist][angle]>(self.avg+5*self.std)):
                poi=1
        if(poi==1):
            hq.heappush(self.cluster_queue,PrioritizedItem(angle,(ClusterPotential(graph[dist][angle],angle,dist,self.dif_measure,self.data_len,self.degrees))))
            self.POI[dist][angle]=100
        else:
            self.POI[dist][angle]=0


    def find_POI_by_med(self,angle,dist):
        if(angle<0):
            angle = self.degrees + angle
        if(self.sprc[dist][angle]>(self.avg_noise + self.std)):
            self.POI[dist][angle]=100
            hq.heappush(self.cluster_queue,(PrioritizedItem(angle,(ClusterPotential(self.proc_sprc[angle][dist],angle,dist,self.dif_measure,self.data_len,self.degrees)))))
        else:
            self.POI[dist][angle]=0

    def deq_cluster(self, angle):
        #print(len(self.cluster_queue))
        if(not self.cluster_queue):
            return
        nxt = hq.heappop(self.cluster_queue)
        #print("angle = " + str(angle))
        while(nxt.priority<=angle):
            #print("nxt prio = "+str(nxt.priority))
            dist = nxt.item.get_dist()
            angle2 = nxt.item.get_angle()
            if(self.clusters[dist][angle2]==0):
                nxt.item.set_val(self.proc_sprc[dist][angle2],self.dif_measure)
                #print(" = ",nxt.item.get_POI())
                #print("val = ",nxt.item.get_val())
                if(nxt.item.is_clust()==True):
                    self.clusters[dist][angle2]=100
                    #self.temp_sprc[dist][angle2]=100
                    more = nxt.item.get_next()
                    for i in range(8):
                        self.cluster_enq(self.proc_sprc[dist][angle2], more[i])
            if(not self.cluster_queue):
                return
            nxt = hq.heappop(self.cluster_queue)
        hq.heappush(self.cluster_queue,nxt)


    def sim_value(self, index):
        #if not at end of row
        if(index%(self.data_len)!=(self.degrees-1)%self.data_len):
            if abs(self.unpr[index+1]-self.unpr[index])<self.std:
                self.POI[index+1]=0
            else:
                self.POI[index+1]=100
        if(index<(self.degrees*self.data_len-self.degrees)):
            if abs(self.unpr[index+self.degrees]-self.unpr[index])<self.std:
                self.sprc[index+self.degrees]=0
            else:
                self.sprc[index+self.degrees]+=100
    

    def cluster(self, angle, dist):
        if(self.clusters[dist][angle]==0):
            self.clusters[dist][angle]=self.sprc[dist][angle]
            val = self.sprc[dist][angle]
            for i in range(1):
                if(angle>i):
                    if(self.clusters[dist][angle-i]==0 and abs(val-self.sprc[dist][angle-i])<self.dif_measure):
                        self.cluster(angle-i,dist)
                if(angle<self.degrees-i):
                    if(self.clusters[dist][angle+i]==0 and abs(val - self.sprc[dist][angle+i])<self.dif_measure):
                        self.cluster(angle+i,dist)
                if(dist>ignore+i):
                    if(self.clusters[dist-i][angle]==0 and abs(val - self.sprc[dist-i][angle])<self.dif_measure):
                        self.cluster(angle, dist-i)
                if(dist<self.data_len-i):
                    if(self.clusters[dist+i][angle]==0 and abs(val - self.sprc[dist+i][angle])<self.dif_measure):
                        self.cluster(angle,dist+i)


    def cluster_enq(self, ref_val, nxt):
        hq.heappush(self.cluster_queue,PrioritizedItem(nxt[1],ClusterPotential(ref_val, nxt[1],nxt[0],self.dif_measure,self.data_len,self.degrees)))


    def calc_avg_noise(self):
        #self.last_check = self.cur_angle
        angle = self.cur_angle
        round = self.round
        self.avg_noise = 0

        while(angle>=0 and round>0):
            for i in range(ignore,self.data_len):
                self.avg_noise +=self.unpr[self.calc_dist(i)*self.degrees+angle]
            angle-=1
            round-=1

        angle=self.degrees-1
        while(round>0):
            for i in range(ignore,self.data_len):
                self.avg_noise +=self.unpr[self.calc_dist(i)*self.degrees+angle]
                angle-=1
                round-=1
        self.avg_noise=self.avg_noise/(self.round*(self.true_data_len))

        rospy.loginfo(f"avg noise = {self.avg_noise}")
        self.calc_std()

    def calc_std(self):
        angle=self.cur_angle
        round=self.round
        self.std_noise=0

        while(angle>=0 and round>0):
            for i in range(ignore,self.data_len):
                self.std_noise += (self.avg_noise-self.unpr[self.calc_dist(i)*self.degrees+angle])*(self.avg_noise-self.unpr[self.calc_dist(i)*self.degrees+angle])
            angle-=1
            round-=1

        angle=self.degrees-1
        while(round>0):
            for i in range(ignore,self.data_len):
                self.std_noise += (self.avg_noise-self.unpr[self.calc_dist(i)*self.degrees+angle])*(self.avg_noise-self.unpr[self.calc_dist(i)*self.degrees+angle])
                angle-=1
                round-=1

        self.std_noise=math.sqrt(self.std_noise/(self.round*(self.true_data_len)))
        rospy.loginfo(f"avg std = {self.std_noise}")

    def detect_contrast(self,arr):
        angle=self.cur_angle

        std = np.std(arr)
        for i in range(ignore+1,self.data_len):
            if abs(arr[i-ignore]-arr[i-1-ignore])>std:
                self.prc[i][angle]=arr[i-ignore]
            else:
                self.prc[i][angle]=0

def sonar_listen():
    s = GraphContainer()
    rospy.spin()
    #arr = np.reshape(s.unpr, (200,400))
    rospy.loginfo(f"{s.unpr}")
    #rospy.loginfo(f"{arr}")

if __name__ == '__main__':
    sonar_listen()
