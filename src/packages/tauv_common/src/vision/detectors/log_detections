#!/usr/bin/env python3

import rospy
from tauv_msgs.msg import Pose, BucketDetection, Header, BucketList
from std_msgs.msg import Header
import numpy as numpy
import cv2
from darknet_ros.msgs.msg import BoundingBoxes
from sensor_msgs.msg import Image, CameraInfo
from depth_estimation import DepthEstimator
from detector_bucket import Detector_Bucket
from tauv_msgs.srv import RegisterObjectDetections

class LogDetections():
    def __init__(self):
        self.cur_position = (0,0,0)
        self.cur_orientation = (0,0,0)

        self.new_image = False

        self.depth_camera_info = CameraInfo()
        self.bounding_boxes = BoundingBoxes()
        
        
        self.depth_image_streamer = rospy.Subscriber("zedm_A/zed_node_A/depth/depth_registered",Image,self.depth_callback)
        self.depth_camera_info = rospy.Subscriber("/zedm_A/zed_node_A/left/camera_info",CameraInfo, self.camera_info_callback)
        self.bounding_boxes = rospy.Subscriber("/darknet_ros/bounding_boxes", BoundingBoxes, self.bbox_callback)

        rospy.Subscriber("gnc/pose", Pose, self.update_position)

        

    def update_position(self,data):
        self.cur_position = (data.position.x, data.position.y, data.position.z)

    def camera_info_callback(self, msg):
        self.depth_camera_info = msg

    def depth_callback(self, msg):
        self.depth_image = self.cv_bridge.imgmsg_to_cv2(msg, "passthrough")

    def bbox_callback(self, bboxes):
        fx = self.depth_camera_info.K[0]
        cx = self.depth_camera_info.K[2]
        fy = self.depth_camera_info.K[4]
        cy = self.depth_camera_info.K[5]
        
        for bbox in bboxes:
          center_x = (bbox.xmin + bbox.xmax) // 2
          center_y = (bbox.ymin + bbox.ymax) // 2
          cur_depth = self.estimate_depth(center_x, center_y, 5, bbox)

          if (cur_depth != np.nan):
            cur_x = ((center_x - cx) * cur_depth) / (fx)
            cur_y = ((center_y - cy) * cur_depth) / (fy)
            print(bbox.Class, cur_x, cur_y, cur_depth)
            self.object_dict[bbox.Class] = (cur_depth, cur_x, cur_y)

            objdet = BucketDetection()
            objdet.tag = bbox.Class
            objdet.position = (self.cur_position.x + cur_depth, self.cur_position.y+cur_x, self.cur_position.z +cur_y)



          else: 
            print(cur_depth)
        self.new_box = True

def object_listen():
    s = LogDetections()
    rospy.spin()

if __name__=='__main__':
    object_listen()