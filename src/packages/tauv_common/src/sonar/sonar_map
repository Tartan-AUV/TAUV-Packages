#!/usr/bin/env python3

import rospy
from tauv_msgs.msg import SonarPulse, FeatureDetection, FeatureDetections
from tauv_msgs.srv import SonarControl, FeatureDetectionsSync, SaveHeatMap
from geometry_msgs.msg import Point
import numpy as np
from scipy.ndimage import gaussian_filter
import skimage
from tauv_util.transforms import tf2_transform_to_homogeneous
import tf2_ros as tf2
import cv2 as cv
from typing import Optional
from visualization_msgs.msg import Marker

MAP_PATH = "./maps/"

def make_marker(detection, angle):

    marker = Marker()
    marker.header.frame_id = "kf/odom"
    marker.header.stamp = rospy.Time()
    marker.ns = ""
    marker.id = (int)(angle)
    marker.type = Marker.SPHERE
    marker.action = Marker.ADD
    marker.pose.position.x = detection[0]
    marker.pose.position.y = detection[1]
    marker.pose.position.z = detection[2]
    marker.pose.orientation.x = 0.0
    marker.pose.orientation.y = 0.0
    marker.pose.orientation.z = 0.0
    marker.pose.orientation.w = 1.0
    marker.scale.x = 0.1
    marker.scale.y = 0.1
    marker.scale.z = 0.1
    marker.color.a =  1
    marker.color.r = (angle/400.0)
    marker.color.g = 0
    marker.color.b = 0
    marker.lifetime = rospy.Duration(200)
    
    return marker

class SonarGraph:
    def __init__(self):
        rospy.init_node('sonar_map',anonymous=True)

        self._load_config()
   
        x = rospy.wait_for_message("/sonar/pulse",SonarPulse)

        self.cur_angle = x.angle
        self.data_len = x.data_length

        #cartesian map used for cluster processing
        self.heat_map = np.zeros((self.HEAT_MAP_DIM, self.HEAT_MAP_DIM), dtype=np.float64)

        self.alignment_map = np.zeros_like(self.heat_map, dtype=np.float64)
        self.alignment_recency = np.zeros_like(self.alignment_map, dtype=np.float64)
        self.alignment_reference_time = rospy.get_time()

        #use below to visualize sonar processing
        # self.heat = np.zeros_like(self.heat_map)

        self.global_origin = [self.global_range/2.0, self.global_range/2.0] #yx origin
        self.square_size = self.global_range/self.HEAT_MAP_DIM

        #for to-world transform operations
        self.RELATIVE_POINT_MAP = np.linspace(0, self.range, num=self.num_distances, endpoint=True)

        #subscribes to sonar driver publishings
        self.pulse_reader = rospy.Subscriber("/sonar/pulse",SonarPulse, self.read)
        #starts scanning immediately, might wanna start from false
        self.survey_mode = True

        self.pub = rospy.Publisher("/visualization_marker", Marker, queue_size=10)

        #communicates directly w global map to send survey points
        rospy.wait_for_service("/global_map/sync_detections")
        self.global_map_com = rospy.ServiceProxy("/global_map/sync_detections", FeatureDetectionsSync)

        #survey/start/stop/reset service for mission communications
        self.serve = rospy.Service("/sonar/map", SonarControl, self.handle_sig)
        #service for saving heat maps
        self.map_saver = rospy.Service("/sonar/save_heat_map", SaveHeatMap, self.save_heat_map)

        #used for testing. Publishes all sonar detections
        # self.pub = rospy.Publisher("/feature_detections_sonar", FeatureDetections, queue_size=10)

    def _load_config(self):
        #params for data reading
        self.range = rospy.get_param('sonar_map/device/range')
        self.gradians = rospy.get_param('sonar_map/map/degrees') #not rad OR degrees
        self.num_distances=rospy.get_param('sonar_map/device/num_samples') 
        self.global_range = rospy.get_param('sonar_map/map/global_range') 
        self.residue_factor = rospy.get_param('sonar_map/map/residue_factor') 
        self.confidence_increment = rospy.get_param('sonar_map/map/confidence_increment') 
        self.ignore_radius = rospy.get_param('sonar_map/device/ignore_radius') 
        self.HEAT_MAP_DIM = rospy.get_param('sonar_map/map/map_dimension') 

        #params for heat map processing
        self.blur_sigma = rospy.get_param('sonar_map/map/blur_sigma')
        self.pre_filter_thresh = rospy.get_param('sonar_map/map/pre_filter_thresh')
        self.post_filter_thresh = rospy.get_param('sonar_map/map/post_filter_thresh')
        self.closing_size = rospy.get_param('sonar_map/map/closing_size')
        self.min_object_size = rospy.get_param('sonar_map/map/min_object_size')
        self.line_of_sight_weight = rospy.get_param('sonar_map/map/line_of_sight_weight')

        #alignment thresholding
        self.alignment_thresh = rospy.get_param('sonar_map/map/alignment/intensity_thresh')
        self.alignment_time_thresh = rospy.Time.from_sec(rospy.get_param('sonar_map/map/alignment/sec_thresh'))
        self.alignment_min_points = self.gradians*rospy.get_param('sonar_map/map/alignment/min_mapped')
        self.reference_map_name = rospy.get_param('sonar_map/map/alignment/map_name')

        #tf frame names
        self._tf_namespace: str = rospy.get_param('tf_namespace')
        self._world_frame_name = f'{self._tf_namespace}/odom'
        self._sonar_frame_name = f'{self._tf_namespace}/sonar1'
        self._kf_frame_name = f'{self._tf_namespace}/vehicle'

        self._tf_buffer: tf2.Buffer = tf2.Buffer()
        self._tf_listener: tf2.TransformListener = tf2.TransformListener(self._tf_buffer)

        try:
            reference_map : Optional[np.typing.NDArray[int]] = cv.imload(MAP_PATH+self.alignment_map_name)
            threshed = reference_map>self.alignment_thresh
            self.reference_point_cloud = self._make_point_cloud(threshed)
        except Exception:
            self.reference_point_cloud = None

    #resets the map
    def _reset(self):
        self.heat_map = np.zeros((self.HEAT_MAP_DIM, self.HEAT_MAP_DIM), dtype=np.float64)
        return True

    def _to_rad(self,angle):
        return (angle/400.0)*2*np.pi

    #transforms a point to a 2D heat map coordinate
    def _get_map_square(self, point): #y x z
        row = np.round((point[0]+self.global_origin[0])/self.square_size)
        col = np.round((point[1]+self.global_origin[1])/self.square_size)
        if(row>=0 and row<self.HEAT_MAP_DIM and col>=0 and col<self.HEAT_MAP_DIM):
            return [(int)(row), (int)(col)]
        else:
            raise Exception("Point out of map bounds")

    #transforms a heat map index to a 2D point (x, y) relative to odom frame
    def _map_square_to_point(self, coords):
        #add 0.5 to ensure centerpoint of matrix index
        (down, right) = ((coords[0]+0.5)*self.square_size, (coords[1]+0.5)*self.square_size)
        (y, x) = (down - self.global_origin[0], right - self.global_origin[1])
        return (x, y)

    #service callback. Processes current heat map and sends detections to global maps
    def _survey(self):
        #clears decaying detections that pile-up over-time
        self.heat_map = np.where(self.heat_map>self.pre_filter_thresh, self.heat_map, 0)

        #blur
        blurred = gaussian_filter(self.heat_map, sigma = self.blur_sigma)

        #threshold filter for detections
        threshed = (blurred>self.post_filter_thresh).astype(np.uint8)

        #closing to connect openings
        closed = cv.morphologyEx(threshed, cv.MORPH_CLOSE, cv.getStructuringElement(cv.MORPH_RECT,(self.closing_size, self.closing_size)))

        #find connected components
        numDets, self.labels, stats, centroids = cv.connectedComponentsWithStats(closed)

        #create a feature detections message to pass to map
        detections = FeatureDetections()
        detections.detector_tag = "sonar"
        detections.detections = []
        status = True

        #for visualization
        # self.heat = np.copy(self.heat_map)

        #add center point to buckets
        for contour in range(numDets):
            if(stats[contour,cv.CC_STAT_AREA]>self.min_object_size):
                #add centroid translated by global origin to bucket
                detection = FeatureDetection()
                detection.position = Point(self.square_size*(centroids[contour][0] - self.global_origin[0]),self.square_size*(centroids[contour][1] - self.global_origin[1]),-50)
                detection.orientation = Point(0,0,0)
                detection.tag = "unknown"
                detection.confidence = 0.5
                detection.SE2 = True

                #for detection visualization
                # self.heat = cv.circle(self.heat, (np.round(centroids[contour][0]).astype(int), np.round(centroids[contour][1]).astype(int)), 10, 155, thickness=5)

                #add all detections at once (sonar does clustering) <- probably better to use this
                #this initially leads to redundancy problems since map only clusters across frames. So if sonar
                #detections close together but separate, map will not cluster them together
                # detections.detections.append(detection)

                #OR

                #add detections individually (leave it up to map to cluster)
                detections.detections = [detection]
                status = status and self.global_map_com(detections).success

                #for detection visualization
                # self.pub.publish(detections)
         
        #uncomment below as well if sonars clustering
        # status = self.global_map_com(detections).success

        return status

    #from byte to intensity value ray, with the ignored radius copied
    def _get_ray(self, data):
        sig = np.frombuffer(data, dtype=np.uint8).copy()
        sig[0:self.ignore_radius]=0

        return sig

    #ray filtering: performs max/line-of-sight filtering and return a single detection per ray
    def _line_of_sight_filter(self, sig):
        #sort
        sorted = np.argsort(-sig)

        #calculate scores
        scores = np.array(sig)[sorted]-self.line_of_sight_weight*sorted

        #max arg over values - args
        max_ind = sorted[np.argmax(scores)]
        ray = np.zeros_like(sig)
        ray[max_ind] = 1
        
        #arg 1 else 0
        return sig*ray
        
    def _make_point_cloud(self, threshed):
        # find all coordinates in threshed array map
        coords = np.argwhere(threshed)

        # map over coordinates to get points
        return np.apply_along_axis(self._map_square_to_point, 1, coords)

    def _align_maps(self):
        if(self.reference_point_cloud is None):
            return False

        # do time-based filtering of self.alignment_map based on self.alignment_recency
        time = rospy.get_time()
        dt = time-self.alignment_reference_time
        decay = self.alignment_recency>(dt - self.alignment_time_thresh)

        # make sure there are enough recent points
        if(np.sum(decay.astype(int)<self.alignment_min_points)):
            return False

        threshed = self.alignment_map>self.alignment_thresh
        union = np.logical_and(decay, threshed)

        # find the point cloud
        cur_point_cloud = self._make_point_cloud(union)

        # find transform between cur_point_cloud and reference_point_cloud
        drifted_t_kf = np.eye(4,4)

        # calculate the odom to body transfrom
        world_t_drifted = self._tf_listener(self._world_frame_name, self._kf_frame_name, rospy.Time(0))
        world_t_kf = world_t_drifted * drifted_t_kf

        self.alignment_reference_time = time
        self.alignment_recency += dt

        return world_t_kf


    #TODO the static TFs are quite untested and need some fixing :P
    def _transform_to_world(self, low, mid, high, timestamp = None):
        #assuming northwards 0 degrees and NED
        #TODO TODO TODO THIS TRANSFORM WILL NEED TO BE RECALCULATED AT COMP
        ray_t_sonar = np.zeros((3,3))
        sonar_t_pts = np.empty((self.num_distances, 3, 4))
        sonar_t_pts[:,:,3] = 1

        ray_t_sonar[:,0:2] = [[-np.cos(low), -np.sin(low)],[-np.cos(mid), -np.sin(mid)],[-np.cos(high), -np.sin(high)]]
        
        sonar_t_pts[:,:,0:3] = np.multiply.outer(self.RELATIVE_POINT_MAP,ray_t_sonar)

        timestamp = rospy.Time.now() if timestamp is None else timestamp

        try:
            world_t_sonar_buf = self._tf_buffer.lookup_transform(
            self._world_frame_name,
            self._sonar_frame_name,
            timestamp,
            rospy.Duration(1)
            )

            world_t_sonar = tf2_transform_to_homogeneous(world_t_sonar_buf)
            #TODO rn its just doing a silly little identity mutiplication, change this to TFs
            # H = np.eye(4,4)

            world_t_pts = np.apply_along_axis(lambda x : np.matmul(world_t_sonar,x), 2,  sonar_t_pts)

            return (world_t_pts)

        except (tf2.LookupException, tf2.ConnectivityException, tf2.ExtrapolationException) as e:
            rospy.logwarn(f'Could not get transform from {self._world_frame_name} to {self._sonar_frame_name}: {e}')


    def save_heat_map(self, req):
        show = cv.applyColorMap(np.round(self.heat_map).astype(np.uint8), cv.COLORMAP_JET)
        cv.imsave(MAP_PATH+req.map_name,show)
        return True

    def read(self, data, update_alignment = True):
        #if we are in survey mode
        if not self.survey_mode:
            return

        #transform data to world coordinates
        angle = (data.angle-self.gradians/2)%self.gradians
        coords = self._transform_to_world(self._to_rad(angle-1), self._to_rad(angle), self._to_rad(angle+1), data.header.stamp)

        #gets the signal data
        ray = self._get_ray(data.data)
        signal = self._line_of_sight_filter(ray)

        #retainment of previous map data, scales down to stay within data range
        updated_map = self.heat_map*(1-self.residue_factor)
        
        try:
            self.pub.publish(make_marker(coords[(int)(self.num_distances/2),1], angle))

            prev_points = np.apply_along_axis(self._get_map_square, 1, (coords[self.ignore_radius]))

            #iterates over each point in the ray, transforms it to map coordinate
            for i in range(self.ignore_radius, self.data_len-1):
                cur_points = np.apply_along_axis(self._get_map_square, 1, (coords[i+1]))
                #fits hexagon to approximate sonar ray arc between previous and current distance
                hex = np.concatenate((prev_points, cur_points))
                #fills in the approximated area with the signal detection
                updated_map = cv.fillPoly(updated_map, [hex], signal[i]*(1-self.residue_factor+self.confidence_increment))

                if(update_alignment):
                    self.alignment_map = cv.fillPoly(self.alignment_map, [hex], (int)(ray[i]))
                    self.alignment_recency = cv.fillPoly(self.alignment_recency, [hex], data.header.stamp.to_sec()-self.alignment_reference_time)

                prev_points = cur_points

        #ends loop at first out-of-bounds transform
        except Exception as err:
            rospy.logwarn(err)

        self.heat_map = updated_map+(self.heat_map*self.residue_factor)

        #for visualization
        show = cv.applyColorMap(np.round(self.alignment_map).astype(np.uint8), cv.COLORMAP_JET)
        cv.imshow("Color-map",show)
        cv.waitKey(1)

    #handles the enumerated interactions w sonar map
    def handle_sig(self, req):
        if(req.op==0): #stop reading in data
            self.survey_mode = False
            return True
        elif(req.op==1): #start reading in data
            self.survey_mode = True
            return True
        elif(req.op==2): #survey, pass detections to map
            res = self._survey ()
            return res
        elif(req.op==3): #reset map
            return (self._reset ())
        return False


def main():
    sonar = SonarGraph()
    rospy.spin()

if __name__ == '__main__':
    main()