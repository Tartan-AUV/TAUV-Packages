from typing import Optional
from spatialmath import SE3, SO3, SE2
from math import pi
import yaml

from actuator_client import ActuatorClient
from missions.mission import Mission
from missions.coordinates import Course
from tasks.task import Task, TaskResult
from tasks import dive, gate_dead_reckon, goto, scan_translate, torpedo_24, collect_sample, goto_relative_with_depth, buoy_24, surface, buoy_24_dead_reckon
from enum import IntEnum

# variables 
COURSE = 'finals_sample' # from irvine_24.yaml: 'finals_sample', 'finals_practice', or 'finals'
GATE_SIDE = -1 # -1 = left, 1 = right

with open('irvine_24.yaml', 'r') as file:
    data = yaml.safe_load(file)
coords = Course(**data[COURSE])

class State(IntEnum):
    # start run
    START = 0
    DIVE = 1
    GATE_DEAD_RECKON = 2

    # buoy
    BUOY_GOTO = 3
    BUOY_DEAD_RECKON = 4
    BUOY_CIRCLE = 5

    # torpedo
    TORPEDO_GOTO = 6
    TORPEDO_DEAD_RECKON = 7

    # octagon
    OCTAGON_GOTO = 8
    OCTAGON_SURFACE = 9
    OCTAGON_DIVE = 10
    SAMPLE_PICKUP_DEAD_RECKON = 11
    SAMPLE_DROP = 12

    # marker
    MARKER_GOTO = 13
    MARKER_DEAD_RECKON = 24

    # end run
    STYLE_GOTO = 15
    STYLE = 16
    FINAL_SURFACE = 17

class KFIrvineFinals(Mission):
    def __init__(self):
        # initializing
        self._state = State.START
        self._actuators = ActuatorClient()

        # transformation of coordinates to course frame
        self._wall_t_rear: SE3 = SE3.Rt(SO3(), (coords._wall_t_rear.x, coords._wall_t_rear.y, coords._wall_t_rear.z))
        self._rear_t_course: SE3 = SE3.Rt(SO3(), (coords._rear_t_course.x, coords._rear_t_course.y, coords._rear_t_course.z))
        self._wall_t_course: SE3 = self._wall_t_vehicle_rear * self._vehicle_rear_t_course
        self._wall_t_ref: SE3 = SE3.Rt(SO3(), (coords._wall_t_ref.x, coords._wall_t_ref.y, coords._wall_t_ref.z))
        self._ref_t_gate: SE3 = SE3.Rt(SO3(), (coords._ref_t_gate.x, coords._ref_t_gate.y, coords._ref_t_gate.z))
        self._wall_t_gate: SE3 = self._wall_t_gate * SE3.Rt(SO3.Rz(coords._ref_t_gate.deg, unit='deg'), [0, 0, 0])
        self._course_t_ref = self._wall_t_course.inv() * self._wall_t_ref
        self._course_t_gate = self._wall_t_course.inv() * self._wall_t_gate
        self._gate_offset_y = GATE_SIDE*0.75

        # buoy
        self._ref_t_bouy: SE3 = SE3.Rt(SO3(), (coords._ref_t_bouy.x, coords._ref_t_bouy.y, coords._ref_t_bouy.z))
        self._course_t_buoy = self._course_t_ref * self._ref_t_bouy
        self._course_t_buoy_approach = self._course_t_buoy * SE3.Rt(SO3.Rz(coords._bouy_t_approach.deg), (coords._bouy_t_approach.x, coords._bouy_t_approach.y, coords._bouy_t_approach.z))

        # torpedo
        self._ref_t_torpedo: SE3 = SE3.Rt(SO3.Rz(coords._ref_t_torpedo.deg, unit='deg'), (coords._ref_t_torpedo.x, coords._ref_t_torpedo.y, coords._ref_t_torpedo.z))
        self._course_t_torpedo = self._course_t_ref * self._ref_t_torpedo
        self._course_t_torpedo_approach = self._course_t_torpedo * SE3.Rt(SO3.Rz(coords._torpedo_t_approach.deg), (coords._torpedo_t_approach.x, coords._torpedo_t_approach.y, coords._torpedo_t_approach.z)) 


        # octagon
        self._ref_t_octagon: SE3 = SE3.Rt(SO3(), (coords._ref_t_octagon.x, coords._ref_t_octagon.y, coords._ref_t_octagon.z))
        self._course_t_octagon = self._course_t_ref * self._ref_t_octagon
        self._course_t_octagon_approach = self._course_t_octagon * SE3.Rt(SO3.Rz(coords._octogon_t_approach.deg), (coords._octogon_t_approach.x, coords._octogon_t_approach.y, coords._octogon_t_approach.z)) 

        # marker
        self._ref_t_marker: SE3 = SE3.Rt(SO3(), (coords._ref_t_marker.x, coords._ref_t_marker.y, coords._ref_t_marker.z))
        self._course_t_marker = self._course_t_ref * self._ref_t_marker
        self._course_t_marker_approach = self._course_t_marker * SE3.Rt(SO3.Rz(coords._marker_t_approach.deg), (coords._marker_t_approach.x, coords._marker_t_approach.y, coords._marker_t_approach.z)) 

        # style 
        self._course_t_style = self._course_t_gate * SE3.Rt(SO3.Rz(coords._gate_t_style.deg), (coords._gate_t_style.x, coords._gate_t_style.y, coords._gate_t_style.z)) 

    def entrypoint(self) -> Optional[Task]:
        self._state = State.DIVE
        return dive.Dive(20.0, 2.0, 0.0) 
    
    def transition(self, task: Task, task_result: TaskResult) -> Optional[Task]:
        
        ########### START RUN ############
        if self._state == State.DIVE:
            if task_result.status == dive.DiveStatus.SUCCESS:
                self._state = State.GATE_DEAD_RECKON
                return gate_dead_reckon.Gate(course_t_gate=self._course_t_gate, travel_offset_y=self._gate_offset_y)

        elif self._state == State.GATE_DEAD_RECKON:
            if task_result.status == gate_dead_reckon.GateStatus.SUCCESS:
                self._state = State.TORPEDO_GOTO
                return goto.Goto(self._course_t_torpedo_approach, in_course=True)
        
        ########### TORPEDO ############
        elif self._state == State.TORPEDO_GOTO:
            if task_result.status == goto.GotoStatus.SUCCESS:
                self._state == State.TORPEDO_DEAD_RECKON
                return goto.Goto(self._course_t_torpedo_approach, in_course=True)

        elif self._state == State.TORPEDO_DEAD_RECKON:
            if task_result.status == goto.GotoStatus.SUCCESS:
                self._actuators.shoot_torpedo(1)
                self._actuators.shoot_torpedo(0)
                self._state = State.OCTAGON_GOTO
                return goto.Goto(self._course_t_octagon_approach, in_course=True)
            
        ########### OCTAGON ############
        elif self._state == State.OCTAGON_GOTO:
            if task_result.status == goto.GotoStatus.SUCCESS:
                self._state = State.SAMPLE_PICKUP_DEAD_RECKON
                return goto.Goto(self._course_t_octagon_approach, in_course=True)
            
        elif self._state == State.SAMPLE_PICKUP_DEAD_RECKON:
            if task_result.status == goto.GotoStatus.SUCCESS:
                self._actuators.close_sphincter()
                self._state = State.OCTAGON_SURFACE
                return goto_relative_with_depth.GotoRelativeWithDepth(SE2(), 0)

        elif self._state == State.OCTAGON_SURFACE:
            if task_result.status == goto_relative_with_depth.GotoRelativeWithDepthStatus.SUCCESS:
                self._state = State.OCTAGON_DIVE
                return goto.Goto(self._course_t_octagon_approach, in_course=True)

        elif self._state == State.OCTAGON_DIVE:
            if task_result.status == goto.GotoStatus.SUCCESS:     
                self._actuators.open_sphincter()
                self._state = State.MARKER_GOTO
                return goto.Goto(self._course_t_marker_approach, in_course=True)
            
# can insert some way to pick up second piece if the first was retrieved with vision and if it is seen   
       
        ########### MARKER ############
        elif self._state == State.MARKER_GOTO:
            if task_result.status == goto.GotoStatus.SUCCESS:
                self._state == State.MARKER_DEAD_RECKON
                return goto.Goto(self._course_t_marker_approach, in_course=True)

        elif self._state == State.MARKER_DEAD_RECKON:
            if task_result.status == goto.GotoStatus.SUCCESS:
                self._actuators.drop_marker(0)
                self._actuators.drop_marker(1)
                self._state = State.BUOY_GOTO
                return goto.Goto(self._course_t_buoy_approach, in_course=True)
            

        ########### BUOY ############
        elif self._state == State.BUOY_GOTO:
            if task_result.status == goto.GotoStatus.SUCCESS:
                self._state == State.BUOY_DEAD_RECKON
                return goto.Goto(self._course_t_buoy_approach, in_course=True)

        elif self._state == State.BUOY_DEAD_RECKON:
            if task_result.status == goto.GotoStatus.SUCCESS:
                self._state == State.BUOY_CIRCLE
                return buoy_24_dead_reckon.CircleBuoyDeadReckon(self._course_t_buoy, 
                 circle_radius=1.5, circle_ccw=True, waypoint_every_n_meters=0.5, 
                 circle_depth=0.7,n_torpedos=0)
            
        elif self._state == State.BUOY_CIRCLE:
                self._state = State.STYLE_GOTO
                return goto.Goto(self._course_t_style, in_course=True)
        
        ########### STYLE ############
        elif self._state == State.STYLE_GOTO:
            if task_result.status == goto.GotoStatus.SUCCESS:
                self._state = State.STYLE
                return barrel_roll.BarrelRoll()
            
        elif self._state == State.STYLE:
            if task_result.status == barrel_roll.BarrelRollStatus.SUCCESS:
                self._state = State.FINAL_SURFACE
                return surface.Surface()
            
        else:
            return None


